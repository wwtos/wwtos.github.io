var T=Object.defineProperty;var D=(s,e,t)=>e in s?T(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var r=(s,e,t)=>(D(s,typeof e!="symbol"?e+"":e,t),t);import{w as k}from"./index.48dfbc7e.js";import{m as N,B as S,d as l,N as u,a as m,b as G,S as J,c as E,T as _}from"./index.109bab44.js";class I{createNode(e,t,n){this.send({action:"graph/newNode",payload:{graphIndex:e,nodeType:t,uiData:n}})}removeNode(e,t){this.send({action:"graph/removeNode",payload:{graphIndex:e,nodeIndex:t}})}updateNodes(e,t){const n=t.map(o=>[e.getNode(o),o]),i=JSON.parse(JSON.stringify(n));this.send({action:"graph/updateNodes",payload:{graphIndex:e.graphIndex,updatedNodes:i}})}updateNodesUi(e,t){const n=t.map(o=>[e.getNode(o),o]),i=JSON.parse(JSON.stringify(n));this.send({action:"graph/updateNodesUi",payload:{graphIndex:e.graphIndex,updatedNodes:i}})}connectNode(e,t){this.send(JSON.parse(JSON.stringify({action:"graph/connectNode",payload:{graphIndex:e,connection:t}})))}disconnectNode(e,t){this.send(JSON.parse(JSON.stringify({action:"graph/disconnectNode",payload:{graphIndex:e,connection:t}})))}requestGraph(e){this.send(JSON.parse(JSON.stringify({action:"graph/get",payload:{graphIndex:e}})))}undo(){this.send(JSON.parse(JSON.stringify({action:"graph/undo"})))}redo(){this.send(JSON.parse(JSON.stringify({action:"graph/redo"})))}save(e){e?this.send({action:"io/save",payload:{path:e}}):this.send({action:"io/save"})}load(e){e?this.send({action:"io/load",payload:{path:e}}):this.send({action:"io/load"})}}class F extends I{constructor(){super();r(this,"messages");r(this,"eventListeners");r(this,"engine");this.messages=[],this.eventListeners=[]}send(t){this.messages.push({type:"message",payload:t}),this.flushMessages()}sendRaw(t){this.messages.push(t),this.flushMessages()}onMessage(t){this.eventListeners.push(t)}setEngine(t){this.engine=t,t.worklet.port.onmessage=n=>{const i=JSON.parse(n.data);for(let o of i)for(let d of this.eventListeners)d(o)},this.flushMessages()}flushMessages(){if(this.engine&&this.engine.context.state==="running")for(;this.messages.length>0;){const t=this.messages.splice(0,1)[0];console.log("sending",t),this.engine.send(t)}}}const y={toKey(s){return s.index+","+s.generation},toString(s){return`Index { index: ${s.index}, generation: ${s.generation} }`}},f={get(s,e){if(s.vec[e.index])return N(s.vec[e.index],{Occupied:({data:[t,n]})=>{if(n==e.generation)return t},Open:t=>{}})}},a={getVertex(s,e){return f.get(s.verticies,e)},getVertexData(s,e){var t;return(t=f.get(s.verticies,e))==null?void 0:t.data},getEdge(s,e){return f.get(s.edges,e)},getEdgeData(s,e){var t;return(t=f.get(s.edges,e))==null?void 0:t.data},verticies(s){let e=[];for(let t=0;t<s.verticies.vec.length;t++){let n=s.verticies.vec[t];N(n,{Occupied({data:[i,o]}){e.push([i,{index:t,generation:o}])},Open:i=>{}})}return e},edges(s){let e=[];for(let t=0;t<s.edges.vec.length;t++){let n=s.edges.vec[t];N(n,{Occupied({data:[i,o]}){e.push([i,{index:t,generation:o}])},Open:i=>{}})}return e}};class v{constructor(e,t){r(this,"nodes");r(this,"nodeStore");r(this,"keyedNodeStore");r(this,"keyedConnectionStore");r(this,"changedNodes");r(this,"ipcSocket");r(this,"graphIndex");r(this,"selectedNodes");this.ipcSocket=e,this.nodes={verticies:{vec:[]},edges:{vec:[]}},this.nodeStore=new S(a.verticies(this.nodes)),this.keyedNodeStore=new S(this.getKeyedNodes()),this.keyedConnectionStore=new S(this.getKeyedConnections()),this.changedNodes=[],this.graphIndex=t,this.selectedNodes=[]}getNode(e){return a.getVertexData(this.nodes,e)}getNodeVertex(e){return a.getVertex(this.nodes,e)}update(){this.keyedNodeStore.next(this.getKeyedNodes()),this.keyedConnectionStore.next(this.getKeyedConnections()),this.nodeStore.next(a.verticies(this.nodes))}applyJson(e){this.nodes=e.nodes,this.update()}getKeyedConnections(){let e=[];for(let[t,n]of a.edges(this.nodes)){let i={fromNode:t.from,toNode:t.to,data:t.data};e.push(["("+y.toKey(this.graphIndex)+") "+JSON.stringify(i),i])}return e}getKeyedNodes(){let e=[];for(let[t,n]of a.verticies(this.nodes))e.push(["("+y.toKey(this.graphIndex)+") "+y.toKey(n),t.data,n]);return e}markNodeAsUpdated(e){console.log(`node ${e} was updated`),!this.changedNodes.find(t=>t.index===e.index&&t.generation===e.generation)&&this.changedNodes.push(e)}writeChangedNodesToServer(){this.changedNodes.length>0&&(this.ipcSocket.updateNodes(this,this.changedNodes),this.changedNodes.length=0)}writeChangedNodesToServerUi(){this.changedNodes.length>0&&(this.ipcSocket.updateNodesUi(this,this.changedNodes),this.changedNodes.length=0)}updateNode(e){this.nodeStore.next(a.verticies(this.nodes))}getNodeInputConnection(e,t){const n=this.getNodeVertex(e);if(n&&n.connectionsFrom)return n.connectionsFrom.map(([o,d])=>a.getEdge(this.nodes,d)).filter(o=>o&&l(o.data.fromSocket,t)).map(o=>o&&{fromSocket:o.data.fromSocket,fromNode:o.from,toSocket:o.data.toSocket})[0]}getNodeOutputConnections(e,t){let n=this.getNodeVertex(e);return n?n.connectionsFrom.map(([o,d])=>a.getEdge(this.nodes,d)).filter(o=>o&&l(o.data.toSocket,t)).map(o=>o&&{fromSocket:o.data.fromSocket,toNode:o.to,toSocket:o.data.toSocket}):[]}getNodeSocketDefault(e,t,n){const i=this.getNode(e);if(i){const o=i.defaultOverrides.find(c=>{const h=u.toSocketAndDirection(c);if(h){const{socket:p,direction:g}=h;return l(t,p)&&n.variant===g.variant}});if(o&&o.data)return u.getDefault(o);const d=i.nodeRows.find(c=>{const h=u.toSocketAndDirection(c);if(h){const{socket:p,direction:g}=h;return l(t,p)&&n.variant===g.variant}});if(d&&d.data)return u.getDefault(d)}return{variant:"None"}}getNodePropertyValue(e,t){const n=this.getNode(e);if(n){if(n.properties[t])return n.properties[t];const i=n.nodeRows.find(o=>m(o,{Property({data:[d]}){return d===t}},()=>!1));return i?m(i,{Property:({data:[o,d,c]})=>c},()=>{throw new Error("unreachable")}):void 0}}getNodeSocketXy(e,t,n){const i=this.getNode(e);if(!i)return{x:0,y:0};let o=_;if(i.nodeRows.findIndex(p=>{const g=u.toSocketAndDirection(p),x=u.getHeight(p);if(o+=x,g){const{socket:O,direction:w}=g;return l(t,O)&&w.variant===n.variant}return!1})===-1)return{x:0,y:0};const c=n.variant==="Output"?G:0,h=o-J+E;return{x:i.uiData.x+c,y:i.uiData.y+h}}}class V{constructor(e){r(this,"nodeGraphs");r(this,"ipcSocket");r(this,"ipcListenerRegistered",!1);r(this,"graphWaitingFor",null);r(this,"graphWaitingForEvent",null);this.nodeGraphs={edges:{vec:[]},verticies:{vec:[]}},this.ipcSocket=e}applyJson(e){var t;a.getVertex(this.nodeGraphs,e.graphIndex)||(this.nodeGraphs.verticies.vec[e.graphIndex.index]={variant:"Occupied",data:[{connectionsFrom:[],connectionsTo:[],data:new v(this.ipcSocket,e.graphIndex)},e.graphIndex.generation]}),(t=a.getVertexData(this.nodeGraphs,e.graphIndex))==null||t.applyJson(e)}onMessage([e]){e.action==="graph/updateGraph"&&e.payload.graphIndex===this.graphWaitingFor&&this.graphWaitingForEvent&&(this.graphWaitingFor=null,this.graphWaitingForEvent(e))}async getGraph(e){var t;if(a.getVertex(this.nodeGraphs,e))return a.getVertexData(this.nodeGraphs,e);{this.ipcListenerRegistered||(this.ipcSocket.onMessage(this.onMessage.bind(this)),this.ipcListenerRegistered=!0),this.graphWaitingFor=e;let n=new Promise((o,d)=>{this.graphWaitingForEvent=o});this.ipcSocket.requestGraph(e);let i=await n;this.nodeGraphs.verticies.vec[e.index]={variant:"Occupied",data:[{data:new v(this.ipcSocket,e),connectionsFrom:[],connectionsTo:[]},e.generation]},(t=a.getVertexData(this.nodeGraphs,e))==null||t.applyJson(i.payload)}return a.getVertexData(this.nodeGraphs,e)}getRootGraph(){return a.getVertexData(this.nodeGraphs,{index:0,generation:0})||(this.nodeGraphs.verticies.vec[0]={variant:"Occupied",data:[{data:new v(this.ipcSocket,{index:0,generation:0}),connectionsFrom:[],connectionsTo:[]},0]}),a.getVertexData(this.nodeGraphs,{index:0,generation:0})}}class C{constructor(){r(this,"nameToSocketType");this.nameToSocketType={}}applyJson(e){this.nameToSocketType={...this.nameToSocketType,...e.nameToSocketType}}getSocketInterpolation(e){return N(e,{Simple:({data:[t]})=>{const n=Object.entries(this.nameToSocketType).find(([i,o])=>o===t);return n?[n[0],void 0]:["",void 0]},Numbered:({data:[t,n]})=>{const i=Object.entries(this.nameToSocketType).find(([o,d])=>d===t);return i?[i[0],n]:["",void 0]}})}}const R=!1,b=()=>{let s=new F;const e=k({activeProject:null,soundConfig:{sampleRate:0},resources:[]});return{socket:s,graphManager:new V(s),socketRegistry:new C,globalEngineState:e,windowDimensions:k({width:400,height:400})}},U=Object.freeze(Object.defineProperty({__proto__:null,load:b,ssr:R},Symbol.toStringTag,{value:"Module"}));export{U as _,b as l,R as s};
